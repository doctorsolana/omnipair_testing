/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  parseAddCollateralInstruction,
  parseAddLiquidityInstruction,
  parseBorrowInstruction,
  parseClaimProtocolFeesInstruction,
  parseDistributeTokensInstruction,
  parseFlashloanInstruction,
  parseInitFutarchyAuthorityInstruction,
  parseInitializeInstruction,
  parseLiquidateInstruction,
  parseRemoveCollateralInstruction,
  parseRemoveLiquidityInstruction,
  parseRepayInstruction,
  parseSetGlobalReduceOnlyInstruction,
  parseSetPairReduceOnlyInstruction,
  parseSwapInstruction,
  parseUpdateFutarchyAuthorityInstruction,
  parseUpdateProtocolRevenueInstruction,
  parseUpdateRevenueRecipientsInstruction,
  parseViewPairDataInstruction,
  parseViewUserPositionDataInstruction,
  type ParsedAddCollateralInstruction,
  type ParsedAddLiquidityInstruction,
  type ParsedBorrowInstruction,
  type ParsedClaimProtocolFeesInstruction,
  type ParsedDistributeTokensInstruction,
  type ParsedFlashloanInstruction,
  type ParsedInitFutarchyAuthorityInstruction,
  type ParsedInitializeInstruction,
  type ParsedLiquidateInstruction,
  type ParsedRemoveCollateralInstruction,
  type ParsedRemoveLiquidityInstruction,
  type ParsedRepayInstruction,
  type ParsedSetGlobalReduceOnlyInstruction,
  type ParsedSetPairReduceOnlyInstruction,
  type ParsedSwapInstruction,
  type ParsedUpdateFutarchyAuthorityInstruction,
  type ParsedUpdateProtocolRevenueInstruction,
  type ParsedUpdateRevenueRecipientsInstruction,
  type ParsedViewPairDataInstruction,
  type ParsedViewUserPositionDataInstruction,
} from "../instructions";

export const OMNIPAIR_PROGRAM_ADDRESS =
  "omnixgS8fnqHfCcTGKWj6JtKjzpJZ1Y5y9pyFkQDkYE" as Address<"omnixgS8fnqHfCcTGKWj6JtKjzpJZ1Y5y9pyFkQDkYE">;

export enum OmnipairAccount {
  FutarchyAuthority,
  Pair,
  RateModel,
  UserPosition,
}

export function identifyOmnipairAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): OmnipairAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 247, 160, 182, 140, 128, 211, 226]),
      ),
      0,
    )
  ) {
    return OmnipairAccount.FutarchyAuthority;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([85, 72, 49, 176, 182, 228, 141, 82]),
      ),
      0,
    )
  ) {
    return OmnipairAccount.Pair;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([94, 3, 203, 219, 107, 137, 4, 162]),
      ),
      0,
    )
  ) {
    return OmnipairAccount.RateModel;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([251, 248, 209, 245, 83, 234, 17, 27]),
      ),
      0,
    )
  ) {
    return OmnipairAccount.UserPosition;
  }
  throw new Error(
    "The provided account could not be identified as a omnipair account.",
  );
}

export enum OmnipairInstruction {
  AddCollateral,
  AddLiquidity,
  Borrow,
  ClaimProtocolFees,
  DistributeTokens,
  Flashloan,
  InitFutarchyAuthority,
  Initialize,
  Liquidate,
  RemoveCollateral,
  RemoveLiquidity,
  Repay,
  SetGlobalReduceOnly,
  SetPairReduceOnly,
  Swap,
  UpdateFutarchyAuthority,
  UpdateProtocolRevenue,
  UpdateRevenueRecipients,
  ViewPairData,
  ViewUserPositionData,
}

export function identifyOmnipairInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): OmnipairInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([127, 82, 121, 42, 161, 176, 249, 206]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.AddCollateral;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([181, 157, 89, 67, 143, 182, 52, 72]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.AddLiquidity;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([228, 253, 131, 202, 207, 116, 89, 18]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.Borrow;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([34, 142, 219, 112, 109, 54, 133, 23]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.ClaimProtocolFees;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([105, 69, 130, 52, 196, 28, 176, 120]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.DistributeTokens;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([105, 33, 1, 3, 42, 158, 246, 67]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.Flashloan;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([133, 110, 154, 29, 240, 206, 71, 100]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.InitFutarchyAuthority;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.Initialize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([223, 179, 226, 125, 48, 46, 39, 74]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.Liquidate;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([86, 222, 130, 86, 92, 20, 72, 65]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.RemoveCollateral;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([80, 85, 209, 72, 24, 206, 177, 108]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.RemoveLiquidity;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([234, 103, 67, 82, 208, 234, 219, 166]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.Repay;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([242, 151, 123, 139, 239, 87, 249, 98]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.SetGlobalReduceOnly;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([147, 113, 16, 50, 64, 88, 175, 18]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.SetPairReduceOnly;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([248, 198, 158, 145, 225, 117, 135, 200]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.Swap;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([15, 196, 157, 217, 113, 226, 89, 25]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.UpdateFutarchyAuthority;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([176, 139, 131, 197, 40, 225, 125, 200]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.UpdateProtocolRevenue;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([116, 179, 137, 47, 118, 167, 65, 217]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.UpdateRevenueRecipients;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([30, 231, 169, 73, 19, 161, 44, 252]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.ViewPairData;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([203, 218, 173, 213, 43, 31, 211, 152]),
      ),
      0,
    )
  ) {
    return OmnipairInstruction.ViewUserPositionData;
  }
  throw new Error(
    "The provided instruction could not be identified as a omnipair instruction.",
  );
}

export type ParsedOmnipairInstruction<
  TProgram extends string = "omnixgS8fnqHfCcTGKWj6JtKjzpJZ1Y5y9pyFkQDkYE",
> =
  | ({
      instructionType: OmnipairInstruction.AddCollateral;
    } & ParsedAddCollateralInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.AddLiquidity;
    } & ParsedAddLiquidityInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.Borrow;
    } & ParsedBorrowInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.ClaimProtocolFees;
    } & ParsedClaimProtocolFeesInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.DistributeTokens;
    } & ParsedDistributeTokensInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.Flashloan;
    } & ParsedFlashloanInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.InitFutarchyAuthority;
    } & ParsedInitFutarchyAuthorityInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.Initialize;
    } & ParsedInitializeInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.Liquidate;
    } & ParsedLiquidateInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.RemoveCollateral;
    } & ParsedRemoveCollateralInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.RemoveLiquidity;
    } & ParsedRemoveLiquidityInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.Repay;
    } & ParsedRepayInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.SetGlobalReduceOnly;
    } & ParsedSetGlobalReduceOnlyInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.SetPairReduceOnly;
    } & ParsedSetPairReduceOnlyInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.Swap;
    } & ParsedSwapInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.UpdateFutarchyAuthority;
    } & ParsedUpdateFutarchyAuthorityInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.UpdateProtocolRevenue;
    } & ParsedUpdateProtocolRevenueInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.UpdateRevenueRecipients;
    } & ParsedUpdateRevenueRecipientsInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.ViewPairData;
    } & ParsedViewPairDataInstruction<TProgram>)
  | ({
      instructionType: OmnipairInstruction.ViewUserPositionData;
    } & ParsedViewUserPositionDataInstruction<TProgram>);

export function parseOmnipairInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedOmnipairInstruction<TProgram> {
  const instructionType = identifyOmnipairInstruction(instruction);
  switch (instructionType) {
    case OmnipairInstruction.AddCollateral: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.AddCollateral,
        ...parseAddCollateralInstruction(instruction),
      };
    }
    case OmnipairInstruction.AddLiquidity: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.AddLiquidity,
        ...parseAddLiquidityInstruction(instruction),
      };
    }
    case OmnipairInstruction.Borrow: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.Borrow,
        ...parseBorrowInstruction(instruction),
      };
    }
    case OmnipairInstruction.ClaimProtocolFees: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.ClaimProtocolFees,
        ...parseClaimProtocolFeesInstruction(instruction),
      };
    }
    case OmnipairInstruction.DistributeTokens: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.DistributeTokens,
        ...parseDistributeTokensInstruction(instruction),
      };
    }
    case OmnipairInstruction.Flashloan: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.Flashloan,
        ...parseFlashloanInstruction(instruction),
      };
    }
    case OmnipairInstruction.InitFutarchyAuthority: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.InitFutarchyAuthority,
        ...parseInitFutarchyAuthorityInstruction(instruction),
      };
    }
    case OmnipairInstruction.Initialize: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.Initialize,
        ...parseInitializeInstruction(instruction),
      };
    }
    case OmnipairInstruction.Liquidate: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.Liquidate,
        ...parseLiquidateInstruction(instruction),
      };
    }
    case OmnipairInstruction.RemoveCollateral: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.RemoveCollateral,
        ...parseRemoveCollateralInstruction(instruction),
      };
    }
    case OmnipairInstruction.RemoveLiquidity: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.RemoveLiquidity,
        ...parseRemoveLiquidityInstruction(instruction),
      };
    }
    case OmnipairInstruction.Repay: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.Repay,
        ...parseRepayInstruction(instruction),
      };
    }
    case OmnipairInstruction.SetGlobalReduceOnly: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.SetGlobalReduceOnly,
        ...parseSetGlobalReduceOnlyInstruction(instruction),
      };
    }
    case OmnipairInstruction.SetPairReduceOnly: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.SetPairReduceOnly,
        ...parseSetPairReduceOnlyInstruction(instruction),
      };
    }
    case OmnipairInstruction.Swap: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.Swap,
        ...parseSwapInstruction(instruction),
      };
    }
    case OmnipairInstruction.UpdateFutarchyAuthority: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.UpdateFutarchyAuthority,
        ...parseUpdateFutarchyAuthorityInstruction(instruction),
      };
    }
    case OmnipairInstruction.UpdateProtocolRevenue: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.UpdateProtocolRevenue,
        ...parseUpdateProtocolRevenueInstruction(instruction),
      };
    }
    case OmnipairInstruction.UpdateRevenueRecipients: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.UpdateRevenueRecipients,
        ...parseUpdateRevenueRecipientsInstruction(instruction),
      };
    }
    case OmnipairInstruction.ViewPairData: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.ViewPairData,
        ...parseViewPairDataInstruction(instruction),
      };
    }
    case OmnipairInstruction.ViewUserPositionData: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: OmnipairInstruction.ViewUserPositionData,
        ...parseViewUserPositionDataInstruction(instruction),
      };
    }
    default:
      throw new Error(
        `Unrecognized instruction type: ${instructionType as string}`,
      );
  }
}
