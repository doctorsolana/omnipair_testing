/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type Account,
  type Address,
  type EncodedAccount,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from "@solana/kit";

export const RATE_MODEL_DISCRIMINATOR = new Uint8Array([
  94, 3, 203, 219, 107, 137, 4, 162,
]);

export function getRateModelDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(RATE_MODEL_DISCRIMINATOR);
}

export type RateModel = {
  discriminator: ReadonlyUint8Array;
  /**
   * exp_rate: NAD/millisecond (k_real = exp_rate / NAD)
   * Derived from half_life_ms: exp_rate = ln(2) / half_life_ms
   */
  expRate: bigint;
  /** utilization band edges (NAD-scaled: 0..NAD) */
  targetUtilStart: bigint;
  targetUtilEnd: bigint;
  /**
   * Rate adjustment half-life in milliseconds
   * Controls how fast rates adjust to utilization changes
   * Lower = faster adjustments, Higher = slower adjustments
   */
  halfLifeMs: bigint;
  /**
   * Minimum interest rate floor (NAD-scaled)
   * Rate will not drop below this value
   */
  minRate: bigint;
  /**
   * Maximum interest rate ceiling (NAD-scaled)
   * Rate will not exceed this value (0 = no cap)
   */
  maxRate: bigint;
  /** Initial interest rate for new pairs using this model (NAD-scaled) */
  initialRate: bigint;
};

export type RateModelArgs = {
  /**
   * exp_rate: NAD/millisecond (k_real = exp_rate / NAD)
   * Derived from half_life_ms: exp_rate = ln(2) / half_life_ms
   */
  expRate: number | bigint;
  /** utilization band edges (NAD-scaled: 0..NAD) */
  targetUtilStart: number | bigint;
  targetUtilEnd: number | bigint;
  /**
   * Rate adjustment half-life in milliseconds
   * Controls how fast rates adjust to utilization changes
   * Lower = faster adjustments, Higher = slower adjustments
   */
  halfLifeMs: number | bigint;
  /**
   * Minimum interest rate floor (NAD-scaled)
   * Rate will not drop below this value
   */
  minRate: number | bigint;
  /**
   * Maximum interest rate ceiling (NAD-scaled)
   * Rate will not exceed this value (0 = no cap)
   */
  maxRate: number | bigint;
  /** Initial interest rate for new pairs using this model (NAD-scaled) */
  initialRate: number | bigint;
};

/** Gets the encoder for {@link RateModelArgs} account data. */
export function getRateModelEncoder(): FixedSizeEncoder<RateModelArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["expRate", getU64Encoder()],
      ["targetUtilStart", getU64Encoder()],
      ["targetUtilEnd", getU64Encoder()],
      ["halfLifeMs", getU64Encoder()],
      ["minRate", getU64Encoder()],
      ["maxRate", getU64Encoder()],
      ["initialRate", getU64Encoder()],
    ]),
    (value) => ({ ...value, discriminator: RATE_MODEL_DISCRIMINATOR }),
  );
}

/** Gets the decoder for {@link RateModel} account data. */
export function getRateModelDecoder(): FixedSizeDecoder<RateModel> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["expRate", getU64Decoder()],
    ["targetUtilStart", getU64Decoder()],
    ["targetUtilEnd", getU64Decoder()],
    ["halfLifeMs", getU64Decoder()],
    ["minRate", getU64Decoder()],
    ["maxRate", getU64Decoder()],
    ["initialRate", getU64Decoder()],
  ]);
}

/** Gets the codec for {@link RateModel} account data. */
export function getRateModelCodec(): FixedSizeCodec<RateModelArgs, RateModel> {
  return combineCodec(getRateModelEncoder(), getRateModelDecoder());
}

export function decodeRateModel<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<RateModel, TAddress>;
export function decodeRateModel<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<RateModel, TAddress>;
export function decodeRateModel<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<RateModel, TAddress> | MaybeAccount<RateModel, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getRateModelDecoder(),
  );
}

export async function fetchRateModel<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<RateModel, TAddress>> {
  const maybeAccount = await fetchMaybeRateModel(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeRateModel<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<RateModel, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeRateModel(maybeAccount);
}

export async function fetchAllRateModel(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<RateModel>[]> {
  const maybeAccounts = await fetchAllMaybeRateModel(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeRateModel(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<RateModel>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeRateModel(maybeAccount));
}

export function getRateModelSize(): number {
  return 64;
}
